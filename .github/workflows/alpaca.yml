name: TradingView-Alpaca Bridge
'on':
  repository_dispatch:
    types:
      - trading-signal
  workflow_dispatch:

permissions:
  contents: write

jobs:
  place-order:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Process Trading Signal
        env:
          ALPACA_API_KEY: '${{ secrets.ALPACA_API_KEY }}'
          ALPACA_API_SECRET: '${{ secrets.ALPACA_API_SECRET }}'
          ALPACA_PAPER_TRADING: '${{ secrets.ALPACA_PAPER_TRADING }}'   # "true" or "false"
          SIGNAL_DATA: '${{ toJson(github.event.client_payload) }}'
        run: |
          echo "Received trading signal"
          echo "Payload: ${{ toJson(github.event.client_payload) }}"

          pip install alpaca-trade-api requests

          cat > trade.py << 'EOF'
          import os, json
          from datetime import datetime
          import alpaca_trade_api as tradeapi

          TRADE_LOG_FILE = 'trade_history.json'

          def log_trade(tr):
              try:
                  arr = []
                  if os.path.exists(TRADE_LOG_FILE):
                      with open(TRADE_LOG_FILE, 'r') as f:
                          try: arr = json.load(f)
                          except json.JSONDecodeError: arr = []
                  arr.append(tr)
                  with open(TRADE_LOG_FILE, 'w') as f:
                      json.dump(arr, f, indent=2)
              except Exception as e:
                  print(f"[LOG] Failed to write trade log: {e}")

          def _first_present(d, keys):
              for k in keys:
                  v = d.get(k)
                  if v is not None and str(v).strip() != "":
                      return v
              return None

          def _parse_float(v):
              if v is None: return None
              s = str(v).replace(',', '').strip()
              try: return float(s)
              except (ValueError, TypeError): return None

          def _parse_bool(v):
              if v is None: return False
              return str(v).strip().lower() in ("1","true","yes","y","on")

          def _normalize_symbol(sym: str) -> str:
              s = sym.upper().replace(' ', '')
              if '/' in s: return s
              if s.endswith('USDT'): return s[:-4] + '/USD'
              if s.endswith('USD'):  return s[:-3] + '/USD'
              return s

          def _get_latest_trade_price(api, symbol: str):
              try:
                  lt = api.get_latest_trade(symbol)
                  px = getattr(lt, "price", None) or getattr(lt, "p", None)
                  if px is not None:
                      print(f"[DATA] Latest trade {symbol} = {px}")
                      return float(px)
              except Exception as e:
                  print(f"[DATA] Failed latest trade for {symbol}: {e}")
              return None

          def _get_available_qty(api, symbol: str):
              try:
                  pos = api.get_position(symbol)
                  qty = float(getattr(pos, "qty", "0"))
                  side = getattr(pos, "side", "long")
                  if side.lower() == "long" and qty > 0:
                      return qty
                  return 0.0
              except Exception as e:
                  print(f"[POS] No position for {symbol} (or error): {e}")
                  return 0.0

          def place_order():
              try:
                  api_key = os.environ.get('ALPACA_API_KEY')
                  api_secret = os.environ.get('ALPACA_API_SECRET')
                  paper = os.environ.get('ALPACA_PAPER_TRADING', 'true').lower() == 'true'
                  if not api_key or not api_secret:
                      raise ValueError("Missing Alpaca credentials")

                  raw = os.environ.get('SIGNAL_DATA')
                  if not raw:
                      raise ValueError("No signal data provided")
                  signal = json.loads(raw)
                  print(f"[PAYLOAD] {signal}")

                  symbol_raw = _first_present(signal, ['symbol','ticker'])
                  if not symbol_raw:
                      raise ValueError("No symbol")
                  symbol = _normalize_symbol(symbol_raw)

                  action = signal.get('action')
                  if not action or str(action).lower() not in ('buy','sell'):
                      raise ValueError("Invalid action; expected buy/sell")
                  side = str(action).lower()

                  qty_raw = _first_present(signal, ['order_size','qty','quantity'])
                  qty = _parse_float(qty_raw)

                  notional_raw = _first_present(signal, ['notional','amount_usd','usd'])
                  notional = _parse_float(notional_raw)

                  price_raw = _first_present(signal, ['price','limit_price'])
                  limit_price = _parse_float(price_raw)

                  fractional_flag = _parse_bool(_first_present(signal, ['fractional','fractional_stock']))
                  allow_short = _parse_bool(_first_present(signal, ['allow_short','short','can_short','shorting']))

                  base_url = 'https://paper-api.alpaca.markets' if paper else 'https://api.alpaca.markets'
                  api = tradeapi.REST(api_key, api_secret, base_url, api_version='v2')
                  acct = api.get_account()
                  print(f"[ACCT] status={acct.status} pv=${acct.portfolio_value}")

                  is_crypto = '/' in symbol

                  # ---------- SELL AUTO-CAP ----------
                  def cap_sell_qty(qty_in, notional_in):
                      avail = _get_available_qty(api, symbol)
                      if avail <= 0:
                          print(f"[CAP] No position for {symbol}. Skipping sell.")
                          return 0, None
                      if notional_in is not None:
                          ref_px = limit_price or _get_latest_trade_price(api, symbol)
                          if not ref_px:
                              print("[CAP] Missing ref price for notional cap; skipping.")
                              return 0, None
                          est_qty = notional_in / ref_px
                          capped = min(est_qty, avail)
                          print(f"[CAP] SELL notional ${notional_in} @ {ref_px} => est {est_qty:.6f}, avail {avail:.6f}, using {capped:.6f}")
                          return capped, ref_px
                      if qty_in is None or qty_in <= 0:
                          print("[CAP] Invalid sell qty; skipping.")
                          return 0, None
                          capped = min(qty_in, avail)
                      capped = min(qty_in, avail)
                      print(f"[CAP] SELL qty {qty_in:.6f}, avail {avail:.6f}, using {capped:.6f}")
                      return capped, None

                  params = {'symbol': symbol, 'side': side, 'time_in_force': 'gtc' if is_crypto else 'day'}
                  order_type = None

                  # Auto-cap SELLs
                  if side == 'sell' and not allow_short:
                      qty, _ = cap_sell_qty(qty, notional)
                      if qty <= 0:
                          print(f"[SKIP] No available holdings to sell {symbol}.")
                          return {"skipped": True, "reason": "No holdings"}

                  # ---------- CRYPTO ----------
                  if is_crypto:
                      if qty is None or qty <= 0:
                          raise ValueError("Crypto requires positive qty")
                      params['qty'] = qty
                      if limit_price:
                          params['type'] = 'limit'
                          params['limit_price'] = limit_price
                          order_type = 'limit'
                      else:
                          params['type'] = 'market'
                          order_type = 'market'
                      print(f"[CRYPTO] {order_type.upper()} {side} qty={qty}")

                  # ---------- STOCKS ----------
                  else:
                      if fractional_flag and side == 'buy' and notional is None:
                          if qty is None or qty <= 0:
                              raise ValueError("fractional=true requires qty")
                          ref_px = limit_price or _get_latest_trade_price(api, symbol)
                          notional = qty * ref_px
                          params['notional'] = notional
                          params['type'] = 'market'
                          order_type = 'market'
                          print(f"[STOCK] Fractional BUY ${notional:.2f}")
                      elif notional:
                          params['notional'] = notional
                          params['type'] = 'market'
                          order_type = 'market'
                          print(f"[STOCK] Market notional ${notional}")
                      else:
                          params['qty'] = int(qty)
                          if limit_price:
                              params['type'] = 'limit'
                              params['limit_price'] = limit_price
                              order_type = 'limit'
                          else:
                              params['type'] = 'market'
                              order_type = 'market'
                          print(f"[STOCK] {order_type.upper()} {side} qty={params['qty']}")

                  order = api.submit_order(**params)
                  print(f"[ORDER] {order.id} status={getattr(order, 'status', 'submitted')}")

                  log_trade({
                      "timestamp": datetime.now().isoformat(),
                      "symbol": symbol,
                      "action": side,
                      "qty": params.get("qty"),
                      "notional": params.get("notional"),
                      "limitPrice": limit_price,
                      "orderType": order_type,
                      "allowShort": allow_short,
                      "fractionalRequested": fractional_flag,
                      "status": "success",
                      "orderId": order.id
                  })
                  return {"success": True}

              except Exception as e:
                  print(f"[ERROR] {e}")
                  log_trade({"timestamp": datetime.now().isoformat(), "symbol": symbol if 'symbol' in locals() else 'UNKNOWN', "status": "failed", "error": str(e)})
                  return {"error": str(e)}

          if __name__ == "__main__":
              res = place_order()
              print("Order process completed.")
          EOF

          python trade.py

          echo "Files in directory after script execution:"
          ls -la

      - name: Commit updated trade history
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"
          if [ -f "trade_history.json" ]; then
            git add trade_history.json
            git commit -m "Update trade history [skip ci]" || echo "No changes to commit"
            git push || echo "Failed to push changes"
          else
            echo "trade_history.json not found"
          fi
